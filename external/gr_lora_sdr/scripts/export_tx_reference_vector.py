#!/usr/bin/env python3
"""Generate the reference chirps used by the LoRa transmitter chain.

The C++ modulator block in :mod:`gnuradio.lora_sdr` generates reference
upchirp and downchirp waveforms through ``build_ref_chirps``. This script
reproduces the same computation in Python so that a user can export the
reference vectors for further processing, testing or comparison.

The script stores the upchirp (and optionally the downchirp) to disk and can
print the first few samples for quick inspection.
"""

from __future__ import annotations

import argparse
import math
from pathlib import Path
from typing import Iterable, Tuple

import numpy as np


def _infer_os_factor(samp_rate: float, bandwidth: float) -> int:
    """Derive the integer oversampling factor used by the modulator."""

    if bandwidth <= 0:
        raise ValueError("Bandwidth must be strictly positive")

    ratio = samp_rate / bandwidth
    rounded = int(round(ratio))
    if not math.isclose(ratio, rounded, rel_tol=0, abs_tol=1e-9):
        raise ValueError(
            "The sampling rate must be an integer multiple of the bandwidth "
            f"(got ratio={ratio!r})"
        )
    if rounded <= 0:
        raise ValueError("The derived oversampling factor must be positive")
    return rounded


def build_reference_chirps(sf: int, os_factor: int) -> Tuple[np.ndarray, np.ndarray]:
    """Return the reference upchirp and downchirp used by the TX chain."""

    if sf <= 0:
        raise ValueError("The spreading factor must be positive")
    if os_factor <= 0:
        raise ValueError("The oversampling factor must be positive")

    samples_per_symbol = (1 << sf) * os_factor
    n = np.arange(samples_per_symbol, dtype=np.float64)
    n_os = float(os_factor)
    symbol_bins = float(1 << sf)

    phase = 2.0 * np.pi * ((n * n) / (2.0 * symbol_bins * n_os * n_os) - 0.5 * n / n_os)
    upchirp = np.exp(1j * phase).astype(np.complex64)
    downchirp = np.conj(upchirp)
    return upchirp, downchirp


def save_chirps(
    upchirp: np.ndarray,
    downchirp: np.ndarray,
    output: Path,
    fmt: str,
    include_down: bool,
) -> Iterable[Path]:
    """Persist the computed chirps using the requested format."""

    output = output.expanduser().resolve()
    produced = []

    if fmt == "npz":
        target = output
        if target.suffix != ".npz":
            target = target.with_suffix(".npz")
        if include_down:
            np.savez(target, upchirp=upchirp, downchirp=downchirp)
        else:
            np.savez(target, upchirp=upchirp)
        produced.append(target)
    elif fmt == "npy":
        base = output
        if base.suffix:
            base = base.with_suffix("")
        up_path = base.with_name(base.name + "_up.npy")
        np.save(up_path, upchirp)
        produced.append(up_path)
        if include_down:
            down_path = base.with_name(base.name + "_down.npy")
            np.save(down_path, downchirp)
            produced.append(down_path)
    elif fmt == "txt":
        base = output
        if base.suffix:
            base = base.with_suffix("")
        up_path = base.with_name(base.name + "_up.txt")
        np.savetxt(
            up_path,
            np.column_stack((upchirp.real, upchirp.imag)),
            fmt="%.12e",
            header="real\timag",
        )
        produced.append(up_path)
        if include_down:
            down_path = base.with_name(base.name + "_down.txt")
            np.savetxt(
                down_path,
                np.column_stack((downchirp.real, downchirp.imag)),
                fmt="%.12e",
                header="real\timag",
            )
            produced.append(down_path)
    else:
        raise ValueError(f"Unsupported export format: {fmt}")

    return produced


def format_complex(value: complex) -> str:
    return f"{value.real:+.6f} {value.imag:+.6f}j"


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Export the reference LoRa chirps generated by the transmitter chain.",
    )
    parser.add_argument("--sf", type=int, default=7, help="Spreading factor (default: 7)")
    parser.add_argument(
        "--bw",
        type=float,
        default=125000,
        help="Transmission bandwidth in Hz (used when deriving the oversampling factor)",
    )
    parser.add_argument(
        "--samp-rate",
        type=float,
        default=None,
        help="Sampling rate in Hz. Required when --os-factor is not provided.",
    )
    parser.add_argument(
        "--os-factor",
        type=int,
        default=None,
        help="Explicit oversampling factor (samples per symbol bin). Overrides --samp-rate/--bw.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Destination file or prefix. Defaults to reference_chirps_sf{sf}_os{os}.npz",
    )
    parser.add_argument(
        "--format",
        choices=("npz", "npy", "txt"),
        default="npz",
        help="File format used to save the chirps (default: npz)",
    )
    parser.add_argument(
        "--no-downchirp",
        action="store_true",
        help="Only export the reference upchirp",
    )
    parser.add_argument(
        "--preview",
        action="store_true",
        help="Print the first few samples of each chirp to stdout",
    )

    args = parser.parse_args()

    if args.os_factor is not None:
        os_factor = args.os_factor
    else:
        if args.samp_rate is None:
            raise ValueError("Either --os-factor or --samp-rate must be specified")
        os_factor = _infer_os_factor(args.samp_rate, args.bw)

    upchirp, downchirp = build_reference_chirps(args.sf, os_factor)

    if args.output is None:
        default_name = f"reference_chirps_sf{args.sf}_os{os_factor}"
        suffix = ".npz" if args.format == "npz" else ""
        output = Path(default_name + suffix)
    else:
        output = args.output

    saved_files = save_chirps(upchirp, downchirp, output, args.format, not args.no_downchirp)

    print(
        f"Generated reference chirps with {len(upchirp)} samples per symbol "
        f"(SF={args.sf}, oversampling={os_factor})."
    )
    for path in saved_files:
        print(f"Saved {path}")

    if args.preview:
        preview_len = min(8, len(upchirp))
        print("First samples of the upchirp:")
        for idx in range(preview_len):
            print(f"  up[{idx}] = {format_complex(upchirp[idx])}")
        if not args.no_downchirp:
            print("First samples of the downchirp:")
            for idx in range(preview_len):
                print(f"  down[{idx}] = {format_complex(downchirp[idx])}")


if __name__ == "__main__":
    main()
