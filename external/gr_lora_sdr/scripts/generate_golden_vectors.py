#!/usr/bin/env python3
"""Batch-generate golden LoRa TX IQ vectors (complex64) for parity testing.

For each parameter combination we build a minimal TX flowgraph using the
hierarchical block `lora_sdr_lora_tx`, feed one payload message (deterministic
or random), run the graph to completion and dump the resulting complex baseband
samples plus a sidecar JSON metadata file. Filenames encode parameters so the
existing RX script can auto-infer them.

Output structure (relative to current working directory unless --out-dir):
    golden_vectors/
        tx_sf7_bw125k_cr1_crc1_impl0_ldro_auto_pay16.bin   (CF32 IQ)
        tx_sf7_bw125k_cr1_crc1_impl0_ldro_auto_pay16.json  (metadata)

Only explicit header variants are generated by default (implicit can be added
with --include-implicit). LDRO can be forced on/off or left auto (default).
"""
from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import List
import importlib
import numpy as np
from gnuradio import gr, blocks
import pmt

# Lazy import helper (reuse logic similar to decode script if needed)

def _attempt_import_lora_sdr(user_paths: list[str] | None = None):
    import sys, glob
    tried = []
    def _try(tag: str):
        try:
            return importlib.import_module("gnuradio.lora_sdr"), tag
        except Exception as e:  # noqa
            tried.append((tag, repr(e)))
            return None, tag
    mod, _ = _try("baseline")
    if mod:
        return mod
    for up in user_paths or []:
        if os.path.isdir(up) and up not in sys.path:
            sys.path.insert(0, up)
        mod, _ = _try(f"user:{up}")
        if mod:
            return mod
    # heuristic search (build*/python)
    for pat in ("external/gr_lora_sdr/build*/python", "external/gr_lora_sdr/build*/lib*"):
        for cand in Path('.').glob(pat):
            if cand.is_dir() and str(cand) not in sys.path:
                sys.path.insert(0, str(cand))
            mod, _ = _try(f"auto:{cand}")
            if mod:
                return mod
    detail = "\n".join(f" - {c}: {e}" for c,e in tried)
    raise ImportError("Could not import gnuradio.lora_sdr:\n"+detail)

class SingleTx(gr.top_block):
    def __init__(self, lora_sdr_mod, *, sf:int, bw:int, samp_rate:int, cr:int,
                 has_crc:bool, impl_head:bool, ldro_mode:int, payload:bytes,
                 frame_zero_padd:int=0):
        super().__init__("single_tx")
        self.src_msg = payload
        self.tx = lora_sdr_mod.lora_sdr_lora_tx(
            bw=bw, cr=cr, has_crc=has_crc, impl_head=impl_head,
            samp_rate=samp_rate, sf=sf, ldro_mode=ldro_mode,
            frame_zero_padd=frame_zero_padd, sync_word=[0x12])
        self.snk = blocks.vector_sink_c()
        self.connect(self.tx, self.snk)
        # Defer posting payload until run (avoids indentation issues & allows re-use)

    def run_and_fetch(self):
    # Start scheduler, inject message, then wait for completion
    self.start()
    # Use internal _post on basic block to deliver payload
    self.tx.to_basic_block()._post(pmt.intern('in'), pmt.init_u8vector(len(self.src_msg), list(self.src_msg)))
    self.wait()
    return np.array(self.snk.data(), dtype=np.complex64)


def main():
    ap = argparse.ArgumentParser(description="Generate golden TX IQ vectors")
    ap.add_argument('--module-path', type=str, default=None, help='Path to built gnuradio.lora_sdr python bindings')
    ap.add_argument('--out-dir', type=Path, default=Path('golden_vectors'), help='Destination directory')
    ap.add_argument('--sf', type=str, default='7,8,9', help='Comma list or range (e.g. 7-9)')
    ap.add_argument('--cr', type=str, default='1,2,3,4', help='Coding rates list')
    ap.add_argument('--bw', type=int, default=125000, help='Bandwidth Hz')
    ap.add_argument('--samp-rate', type=int, default=500000, help='Sample rate Hz')
    ap.add_argument('--payload-len', type=int, default=16, help='Payload length bytes')
    ap.add_argument('--crc', action='store_true', default=False, help='Also generate CRC-disabled variants (both)')
    ap.add_argument('--include-implicit', action='store_true', help='Include implicit header variants')
    ap.add_argument('--ldro-modes', type=str, default='2', help='LDRO modes (0,1,2) comma list')
    ap.add_argument('--payload-mode', choices=['fixed','increment','random'], default='fixed', help='Payload content pattern')
    ap.add_argument('--seed', type=int, default=1234, help='Random seed')
    args = ap.parse_args()

    def parse_list(spec:str):
        if '-' in spec and spec.count(',')==0:
            a,b = spec.split('-'); return list(range(int(a), int(b)+1))
        return [int(x) for x in spec.split(',') if x]

    sfs = parse_list(args.sf)
    crs = parse_list(args.cr)
    ldros = parse_list(args.ldro_modes)

    if args.module_path:
        import sys
        if args.module_path not in sys.path:
            sys.path.insert(0, args.module_path)
    lora_sdr = _attempt_import_lora_sdr([args.module_path] if args.module_path else None)

    rng = np.random.default_rng(args.seed)

    out_dir = args.out_dir.expanduser().resolve()
    out_dir.mkdir(parents=True, exist_ok=True)

    produced: List[str] = []
    total = 0
    for sf in sfs:
        for cr in crs:
            for ldro in ldros:
                for impl in ([False, True] if args.include_implicit else [False]):
                    for crc_flag in ([True, False] if args.crc else [True]):
                        # build payload
                        if args.payload_mode == 'fixed':
                            payload = b'TEST_PAYLOAD_' + bytes([sf, cr])
                        elif args.payload_mode == 'increment':
                            payload = bytes((i % 256 for i in range(args.payload_len)))
                        else:
                            payload = rng.integers(0,256,size=args.payload_len, dtype=np.uint8).tobytes()
                        payload = payload[:args.payload_len]
                        tb = SingleTx(lora_sdr, sf=sf, bw=args.bw, samp_rate=args.samp_rate,
                                      cr=cr, has_crc=crc_flag, impl_head=impl,
                                      ldro_mode=ldro, payload=payload)
                        iq = tb.run_and_fetch()
                        stem = f"tx_sf{sf}_bw{args.bw}_cr{cr}_crc{int(crc_flag)}_impl{int(impl)}_ldro{ldro}_pay{len(payload)}"
                        bin_path = out_dir / f"{stem}.cf32"
                        iq.astype(np.complex64).tofile(bin_path)
                        meta = {
                            'sf': sf, 'bw': args.bw, 'cr': cr, 'crc': bool(crc_flag),
                            'impl_header': bool(impl), 'ldro_mode': ldro,
                            'samp_rate': args.samp_rate, 'payload_len': len(payload),
                            'payload_hex': payload.hex(), 'filename': bin_path.name
                        }
                        (out_dir / f"{stem}.json").write_text(json.dumps(meta, indent=2))
                        produced.append(bin_path.name)
                        total += 1
                        print(f"[gen] {bin_path.name} samples={len(iq)}")
    print(f"Generated {total} golden vectors in {out_dir}")

if __name__ == '__main__':
    main()
