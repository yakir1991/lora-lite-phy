LoRa(WAN) Webinar

LoRa â€“ Modulation/Encoding
Author: Harald Eigner (TU Wien)
These slides give an overview on the LoRa modulation and encoding. While the first slides are
intended for general audience, the second part will explain modulation/encoding on a very
detailed level, targeting advanced audience which want to generate/receive signals with their own
hardware, like software defined radios.

Contents
â€¢ Spread Spectrum Basics
â€¢ LoRa Chirped Spread Spectrum
â€¢ LoRa Frame Format
â€¢ LoRa Encoding Scheme
â€¢ Airtime

2

Contents
â€¢ Spread Spectrum Basics
â€¢ LoRa Chirped Spread Spectrum
â€¢ LoRa Frame Format
â€¢ LoRa Encoding Scheme
â€¢ Airtime

3

Spread Spectrum Basics
â€¢ Information is spread over frequency, high bandwidth
â€¢ Trade-off between data rate, bandwidth, and power

amplitude

with

ğ¶ğ¶ = ğµğµğµğµ log 2 1 +
ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘

â€¢ ğ¶ğ¶ â€¦ Channel Capacity
ğ‘ ğ‘ 
â€¢ ğµğµğµğµ â€¦ Bandwidth ğ»ğ»ğ‘§ğ‘§
ğ‘†ğ‘†
â€¢
â€¦ Signal to Noise ratio 1
ğ‘ğ‘

spectrum of signal
spectrum of spreaded signal

ğ‘†ğ‘†
ğ‘ğ‘

f

c

frequency

4

Direct Sequence Spread Spectrum
Tbit
1

data

â€¢ Data signal is expanded by multiplying with
pseudo random sequence â€“ spreading code
â€¢ Information is spread over frequency

time

0
Tchip

spreading code

DSSS signal

1
0

0

1
0

1

1

1
0

1

0

0

1

1
0

time

0

time

1
ğ‘‡ğ‘‡ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘
1
ğ‘…ğ‘…ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ =
ğ‘‡ğ‘‡ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘
ğ‘…ğ‘…ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ =

5

Contents
â€¢ Spread Spectrum Basics
â€¢ LoRa Chirped Spread Spectrum
â€¢ LoRa Frame Format
â€¢ LoRa Encoding Scheme
â€¢ Airtime

6

LoRa Chirped Spread Spectrum Modulation
â€¢ LoRa Chirp: signal with linearly increasing frequency
â€¢ Chirp length is determined by the spreading factor SF
â€¢ Information is spread over time

7

LoRa Chirped Spread Spectrum Modulation
â€¢ Parameters defining the chirp:
â€¢ Spreading factor
â€¢ Bandwidth
â€¢ Code Rate
â€¢ Chirp length

ğ‘†ğ‘†ğ‘†ğ‘† = 7 â€¦ 12
ğµğµğ‘Šğ‘Š = 125, 250, 500 ğ‘˜ğ‘˜ğ‘˜ğ‘˜ğ‘˜ğ‘˜
ğ¶ğ¶ğ¶ğ¶ = 4â„5 , 4â„6 , 4â„7 , 4â„8
2ğ‘†ğ‘†ğ‘†ğ‘†
ğ‘‡ğ‘‡ğ‘†ğ‘† =
ğµğµğµğµ

LoRa chirps with ğ‘†ğ‘†ğ‘†ğ‘† = 7 â€¦ 12

8

LoRa Chirped Spread Spectrum Modulation
â€¢ Data encoded in cyclically shifted frequency ramp
with disabled low data rate mode

ğ‘†ğ‘†ğ‘†ğ‘†
ğ‘ğ‘ = ï¿½
ğ‘†ğ‘†ğ‘†ğ‘† âˆ’ 2

â€¢ Symbol alphabet size
â€¢ Symbol alphabet

with enabled low data rate mode

ğ‘ğ‘ âˆˆ 0, â€¦ , ğ‘€ğ‘€ âˆ’ 1
f

chirp

BW
2

t
a
- Ts
2

Ts
2

- BW
2

Ts +t
2 a

time

raw upchirp
chirp associated to symbol

9

LoRa Chirped Spread Spectrum Modulation
â€¢ Bit Error Ratio over Signal to Noise Ratio

â€¢ SNR = -22 dB for BER = 10âˆ’4 with ğ‘†ğ‘†ğ‘†ğ‘† = 12

LDR â€¦ Low data rate mode
10

LoRa Chirped Spread Spectrum Modulation
â€¢ Receiver Sensitivity: Receiving power at which a certain maximum BER is achieved
â€¢ Example:
â€¢
â€¢
â€¢
â€¢

ğµğµğ‘Šğ‘Š = 125 ğ‘˜ğ‘˜ğ‘˜ğ‘˜ğ‘˜ğ‘˜
Noise Figure ğ‘ğ‘ğ¹ğ¹ = 6 ğ‘‘ğ‘‘ğ‘‘ğ‘‘
ğ‘†ğ‘†ğ¹ğ¹ = 12
ğ‘†ğ‘†ğ‘†ğ‘†ğ‘…ğ‘… = âˆ’22 ğ‘‘ğ‘‘ğ‘‘ğ‘‘ for ğµğµğµğµğµğµ = 10âˆ’4

ğ‘†ğ‘† = âˆ’174 + 10 log10 ğµğµğµğµ + ğ‘ğ‘ğ‘ğ‘ + ğ‘†ğ‘†ğ‘†ğ‘†ğ‘†ğ‘†
ğ‘†ğ‘† = âˆ’174 + 10 log10 125 ï¿½ 103 + 6 âˆ’ 22 = âˆ’ğŸğŸğŸğŸğŸğŸ ğ’…ğ’…ğ’…ğ’…ğ’…ğ’…

â€¢ Link Budget:
â€¢ Antenna transmit power ğ‘ƒğ‘ƒ = +15 ğ‘‘ğ‘‘ğ‘‘ğ‘‘ğ‘‘ğ‘‘

ğ¿ğ¿ğ¿ğ¿ğ¿ğ¿ğ¿ğ¿ ğµğµğµğµğµğµğµğµğµğµğµğµ = ğ‘ƒğ‘ƒ âˆ’ ğ‘†ğ‘† = 15 ğ‘‘ğ‘‘ğ‘‘ğ‘‘ğ‘‘ğ‘‘ âˆ’ âˆ’139 ğ‘‘ğ‘‘ğ‘‘ğ‘‘ğ‘‘ğ‘‘
ğ¿ğ¿ğ¿ğ¿ğ¿ğ¿ğ¿ğ¿ ğµğµğµğµğµğµğµğµğµğµğµğµ = ğŸğŸğŸğŸğŸğŸ ğ’…ğ’…ğ’…ğ’…

11

Contents
â€¢ Spread Spectrum Basics
â€¢ LoRa Chirped Spread Spectrum
â€¢ LoRa Frame Format
â€¢ LoRa Encoding Scheme
â€¢ Airtime

12

LoRa Frame Format
â€¢ Preamble
â€¢ Optional header
â€¢ Payload
â€¢ Cyclic redundancy check CRC

optional

Preamble

Header

optional

Payload

CRC

13

Preamble
â€¢ ğ‘›ğ‘›ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ raw upchirps ğ‘ğ‘1 , ğ‘ğ‘2 , â€¦ ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ for
synchronization at receiver

â€¢ Syncword: two upchirps cs1, cs2, defining
the mode of the communication. Public
or private mode

â€¢ Frame Delimiter FD: 2.25 downchirps ğ‘‘ğ‘‘2 ,
ğ‘‘ğ‘‘2 , and ğ‘‘ğ‘‘3 â€² to end the preamble
â€¢ ğ‘‘ğ‘‘3 â€² describes the chirp with length

ğ‘‡ğ‘‡ğ‘†ğ‘†
4

14

Header
â€¢ Information included in Header:
â€¢
â€¢
â€¢
â€¢

Payload length
Code Rate
Presence of a payload-CRC
Header-CRC

2 Bytes
3 Bit
1 Bit
2 Bytes

â€¢ Has a length of 8 symbols and is always encoded with highest code rate of ğ¶ğ¶ğ¶ğ¶ = 4â„8
â€¢ 8 symbols include information of 56 â€¦ 96 bit ,depending on spreading factor

â€¢ Unused space in the first 8 symbols is filled with payload data
Header

Payload Length

Code Rate

CRCpayload
Presence

CRCheader

15

Payload
â€¢ Payload length 0 â€¦ 255 ğµğµğµğµğµğµğµğµ

â€¢ MAC header: defines message type (data exchange, join request, â€¦)
â€¢ MAC Payload: either generic or LoRaWAN payload
â€¢ Every code rate possible
â€¢ Message Integrity Code MIC: Computed with the network session key
â€¢ Optional Cyclic Redundancy Check CRC: length 2 Bytes

Payload

MAC header

MAC payload

CRC

MIC

CRC

16

Contents
â€¢ Spread Spectrum Basics
â€¢ LoRa Chirped Spread Spectrum
â€¢ LoRa Frame Format
â€¢ LoRa Encoding Scheme
â€¢ Airtime

17

LoRa Encoding
â€¢ Several encoding steps to increase resilience against interference
â€¢ Different treatment for header and payload
â€¢ Example with ğ‘†ğ‘†ğ‘†ğ‘† = 8, ğ¶ğ¶ğ¶ğ¶ = 4/5, ğ¿ğ¿ğ‘ğ‘ = 2ğµğµğµğµğµğµğµğµ, and payload ğ‘ğ‘ =

h

header

Encoding
CR = 4/8

L =SF-2
h

0x 00
0x 00

he
Interleaving

payload
Encoding

Whitening
L
p

L
p'

ai

pe

pw

p

Interleaving
L
p'

a
GrayMapping

N
Payload

N
Payload

18

Whitening
â€¢ Removes DC-bias in data; only payload gets
whitened
â€¢ XOR with whitening sequence w
â€¢ ğ‘ğ‘ğ‘¤ğ‘¤ = ğ‘ğ‘ âŠ• ğ‘¤ğ‘¤

payload
pw

p
Whitening
L
p

L
p'

â€¢ Whitening sequence from linear feedback
shift register with polynomial:
â€¢ ğ‘¤ğ‘¤ ğ‘¥ğ‘¥ = ğ‘¥ğ‘¥ 4 âŠ• ğ‘¥ğ‘¥ 3 âŠ• ğ‘¥ğ‘¥ 2 âŠ• 1

0x ğ¹ğ¹ğ¹ğ¹
0x ğ¹ğ¹ğ¹ğ¹
ğ‘¤ğ‘¤ =
first bytes of the whitening sequence
0x ğ¹ğ¹ğ¹ğ¹
â€¦

x7

x6

x5

x4

x2

x3

8
8

x1

x0

whitening sequence w(x)
data

19

Whitening Example
â€¢ Payload
â€¢ Whitening sequence

â€¢ Whitened payload

0x 00
0x 00
0x ğ¹ğ¹ğ¹ğ¹
ğ‘¤ğ‘¤ =
0x ğ¹ğ¹ğ¹ğ¹
ğ‘ğ‘ =

ğ‘ğ‘ğ‘¤ğ‘¤ = ğ‘ğ‘ âŠ• ğ‘¤ğ‘¤ =

payload
pw

p
Whitening
L
p

L
p'

0x ğ¹ğ¹ğ¹ğ¹
0x ğ¹ğ¹ğ¹ğ¹

20

Whitening Matlab Implementation
function p = compute_whitening(p)
%COMPUTE_WHITENING performs a whitening of the databytes p
%
The function performs a whitenig of the databits p. The whitening
%
sequence is computed with a LFSR with the polynomial:
%
w(x) = x^4 xor x^3 xor x^2 xor 1 and a starting value of 0x FF
register = double(0xFF); % starting value of 0x FF
%perform whitening
for idx = 1 : length(p)
p(idx) = bitxor(p(idx), register);
feedback = mod(sum(dec2binvec(bitand(register, double(0xB8)))), 2);
register = bitand(register * 2, double(0xFF)) + feedback;
end

21

Encoding
â€¢ Four different code-rates
â€¢
â€¢
â€¢
â€¢

ğ¶ğ¶ğ¶ğ¶ = 4/5
ğ¶ğ¶ğ¶ğ¶ = 4/6
ğ¶ğ¶ğ¶ğ¶ = 4/7
ğ¶ğ¶ğ¶ğ¶ = 4/8

parity check
shortened (4,7) Hamming code
(4,7) Hamming code
extended (4,7) Hamming code

â€¢ Header is always encoded with ğ¶ğ¶ğ¶ğ¶ = 4/8 and low
data rate mode -> length ğ¿ğ¿â„ = ğ‘†ğ‘†ğ‘†ğ‘† âˆ’ 2 nibbles of 4 Bit

header

h

Encoding
CR = 4/8

L =SF-2
h

he

pe

pw
Encoding
L
p'

L
p'

â€¢ Remaining space is filled with payload data

â€¢ Small payload may fit completely in header symbols
â€¢ Data ğ‘ğ‘ğ‘¤ğ‘¤ transformed from Bytes to Nibbles of 4 Bit

22

Encoding
â€¢ Parity bits:

CR = 4/8
CR = 4/7
CR = 4/6
CR = 4/5

p3

â€¢ Parity bit calculation:

p2

p1

p0

d3

d2

d1

d0

p2

p1

p0

d3

d2

d1

d0

p1

p0

d3

d2

d1

d0

p4

d3

d2

d1

d0

23

Encoding
â€¢ Error correction capabilities:

Error Detection
code rate

bit error

1

2

Error Correction
3

4

code rate

bit error

4/5

4/5

4/6

4/6

4/7

4/7

4/8

4/8

1

2

3

4

24

Encoding Example
â€¢ Header

ğ¿ğ¿â„ = ğ‘†ğ‘†ğ‘†ğ‘† â€“ 2 = 6

0x 0
0 0
0 0
0x 2
0 0
0x 2
â„=
=
0x 0
0 0
0x ğ¸ğ¸
1 1
0x ğ¹ğ¹
1 1

â€¢ Payload

0x ğ¹ğ¹
1 1
0x ğ¹ğ¹
1 1
=
ğ‘ğ‘ğ‘¤ğ‘¤ =
0x ğ¸ğ¸
0 1
0x ğ¹ğ¹
1 1

0
1
1
0
1
1

0
0
0
0
0
1

1 1
1 1
1 1
1 1

h

header

Encoding
CR = 4/8

L =SF-2
h

ğ¿ğ¿ğ‘ğ‘ = 2

pe

pw

ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ disabled
ğ¶ğ¶ğ¶ğ¶ = 4/5
Header CRC

he

Encoding
L
p'

L
p'

Remaining space is filled with
Payload data

1 1
ğ‘ğ‘ğ‘¤ğ‘¤ â€² = 0 1
1 1

1 1
1 1
1 1
25

Encoding Example cont.
header

â€¢ Header ğ¶ğ¶ğ¶ğ¶ = 4/8

0
0
0
â„ğ‘’ğ‘’ =
0
0
1

0
1
1
0
0
1

0
1
1
0
1
1

â€¢ Payload ğ¶ğ¶ğ¶ğ¶ = 4/5

0
1
1
0
0
1

0
0
0
0
1
1

0
0
0
0
1
1

0
1
1
0
1
1

Encoding
CR = 4/8

L =SF-2
h

header bits

parity bits

h

0
0
0
0
0
1

he

pe

pw
Encoding
L
p'

L
p'

parity bits payload bits

0 1
ğ‘ğ‘ğ‘’ğ‘’ = 1 0
0 1

1 1
1 1
1 1

1
1
1

26

Encoding Matlab Implementation

function codewords = encoder(B, CR)
%ENCODE Data encoding
%
This function encodes the input data from
%
matrix B with code rate:
%
CR = 1 ... code rate 4/5
%
CR = 2 ... code rate 4/6
%
CR = 3 ... code rate 4/7
%
CR = 4 ... code rate 4/8
len = size(B, 1);
N = CR;
k = 4;
codewords = zeros(len, k);
P = zeros(k, N - k);
I = logical(eye(k));

%Create generator matrix G
if CR > 5
for idx = 1 : 4
P(idx, 1) = xor(xor(I(idx, 1), I(idx, 2)), I(idx, 3));
P(idx, 2) = xor(xor(I(idx, 2), I(idx, 3)), I(idx, 4));
P(idx, 3) = xor(xor(I(idx, 1), I(idx, 2)), I(idx, 4));
P(idx, 4) = xor(xor(I(idx, 1), I(idx, 3)), I(idx, 4));
end
%Create generator matrix for CR = 1 ... 3
G=[I P(1 : 4, 1 : (CR - 4))]; elseif CR == 5
for idx = 1:4
P(idx, 1) = xor(xor(I(idx, 1), I(idx, 2)), xor(I(idx, 3), I(idx, 4)));
end
G=[I P];
%Create generator matrix for CR = 4
end
%Generation of codewords
for idx1 = 1 : len
for idx2 = 1 : N
%multiplication data with generator matrix c = u * G
codewords(idx1, idx2 )= mod(sum(B(idx1, :).*G(:, idx2)'), 2);
end
end
end

27

Interleaver
he

â€¢ Diagonal interleaver

Interleaving

â€¢ Multiple bit errors caused by one symbol are
highly correlated

b1,4

b1,3 b1,2

b1,1

b2,5

b2,4

b2,3 b2,2

b2,1

b3,5

b3,4

b3,3 b3,2

b3,1

b4,5

b4,4

b4,3 b4,2

b5,5

b5,4

b6,5
b7,5

Interleaving
L
p'

b6,5

b5,5

b4,5

b3,5

b2,5 b1,5

b1,4 b7,4

b6,4

b5,4

b4,4

b3,4

b2,4

b4,1

b2,3 b1,3 b7,3

b6,3

b5,3

b4,3

b3,3

b5,3 b5,2

b5,1

b3,2

b2,2 b1,2 b7,2

b6,2

b5,2

b4,2

b6,4

b6,3 b6,2

b6,1

b4,1

b3,1

b2,1 b1,1 b7,1

b6,1

b5,1

b7,4

b7,3 b7,2

b7,1

codeword length

b7,5

interleaving

symbol alphabet size N

Interleaving example with ğ‘†ğ‘†ğ‘†ğ‘† = 7 and ğ¶ğ¶ğ¶ğ¶ = 4/5

codeword length

symbol alphabet size N

â€¢ Spreads multiple bit errors over multiple
codewords -> decorrelation

b1,5

ai

pe

N
Payload

symbol alphabet size:
disabled low data rate mode
ğ‘†ğ‘†ğ‘†ğ‘†
N=ï¿½
ğ‘†ğ‘†ğ‘†ğ‘† âˆ’ 2 enabled low data rate mode
codeword length:
â€¢ 5 bit
for ğ¶ğ¶ğ¶ğ¶ = 4â„5
â€¢ 6 bit
for ğ¶ğ¶ğ¶ğ¶ = 4â„6
â€¢ 7 bit
for ğ¶ğ¶ğ¶ğ¶ = 4â„7
â€¢ 8 bit
for ğ¶ğ¶ğ¶ğ¶ = 4â„8

28

Interleaver Matlab Implementation
function B_int = interleave(B)
%INTERLEAVE interleaves the binary codeblock B
%
This function performs the diagonal interleaving of the codeblock B. It transoforms
%
the binary matrix B of size symbol alphabet times codeword length (N x CR + 4) to the binary
%
matrix B_int of size codeword length times symbol alphabet size (CR + 4 x N)
c = size(B, 1);
s = size(B, 2);
bin_interleaved1 = zeros(c, s);
B_int = zeros(c, s);
%perform interleaving
for idx1 = 1 : c
for idx2 = 1 : s
bin_interleaved1(idx1, idx2) = B(c - (idx1 - 1), idx2);
end
end
for idx1 = 1 : c
for idx2 = 1 : s
B_int(idx1, idx2)=bin_interleaved1(1 + mod(idx1 - idx2, c), idx2);
end
end
B_int = fliplr(B_int.');
end
29

Interleaver Example
he

â€¢ Header

6 bit

8 bit
0
1
1
0
1
1

0
1
1
0
0
1

0
0
0
0
1
1

â€¢ Payload CR

0
0
0
0
1
1

0
1
1
0
1
1

0
0
0
0
0
1

5 bit
1
1
1
0
0
0
0
0

1
1
1
0
0
0
0
0

1
1
1
0
0
0
0
0

0
1
0
0
1
0
0
1

0
1
1
0
1
1
0
0

0
0
1
1
0
1
1
0

0
1
0
1
1
0
1
0

0
1
0
0
0
1
0
0

ai

pe
Interleaving
L
p'

N
Payload

8 bit
0 0 0 0
1 0 0 0
ğ‘ğ‘ğ‘–ğ‘– = 1 1 0 0
1 1 1 0
0 1 1 1

0 0 1
0 0 1
0 0 0
0 0 0
0 0 0

0
0
1
0
0

5 bit

1
0
1
0
0
0
0
0

8 bit

0
1
0
0
ğ‘ğ‘ğ‘’ğ‘’ =
0
0
0
0

1
0
0
0
â„ğ‘–ğ‘– =
0
1
1
0

8 bit

0
1
1
0
0
1

6 bit

0
0
â„ğ‘’ğ‘’ = 0
0
0
1

Interleaving

Payload is extended with random data to get a block of data
with symbol alphabet size N times codeword length

30

Interleaver Example cont.
he

â€¢ Header and payload is stacked to form codewords ai

Interleaving

ai

pe

0
0
0
0
0
0
â„ğ‘–ğ‘–
â„ = ğ‘ğ‘ = 0
ğ‘–ğ‘–
0
0
1
1
1
0

0
0
0
0
0
0
0
0
0
0
1
1
1

1
0
0
0
0
1
1
0
0
0
0
1
1

0
1
0
0
1
0
0
1
0
0
0
0
1

0
1
1
0
1
1
0
0
0
0
0
0
0

0
0
1
1
0
1
1
0
0
0
0
0
0

0
1
0
1
1
0
1
0
1
1
0
0
0

0
0x 02
1
0x ğµğµğµ
0
0x ğ¶ğ¶ğ¶
0
0x 60
0
0x A1
1
0x ğ·ğ·ğ·
0 = 0x 62
0
0x 01
0
0x 20
0
0x 28
1
0x 1C
0
0x 0ğ¸ğ¸
0
0x 09

Interleaving
L
p'

N
Payload

31

Gray Mapping
â€¢ Erroneous symbol most likely mistaken with
adjacent symbol.
â€¢ Gray code maps a bit sequence such that two
successive values differ by just one bit

ai

a
GrayMapping

N
Payload

ğ‘ğ‘ğ‘–ğ‘– (ğ‘—ğ‘—, ğ‘˜ğ‘˜)
ğ‘ğ‘ğ‘—ğ‘— = ï¿½
ğ‘ğ‘ğ‘–ğ‘– ğ‘—ğ‘—, ğ‘˜ğ‘˜ âŠ• ğ‘ğ‘ğ‘–ğ‘– (ğ‘—ğ‘—, ğ‘˜ğ‘˜ âˆ’ 1)

for ğ‘˜ğ‘˜ = 0
else

without Gray mapping

transmitter

N
Payload

with Gray mapping

transmitter
ai = 63

0 1 1 1 1 1 1
Gray mapping

ai = 63

0 1 1 1 1 1 1

a = 65

channel
Ã¢i = 64

1 0 0 0 0 0 0

channel
Ã¢ = 66

7 bit errors

1 0 0 0 0 1 0
Gray demapping

Ã¢i = 62
receiver

1 0 0 0 0 0 1

receiver

0 1 1 1 1 1 0
1 bit error

Receiver mistakes symbol ğ‘ğ‘ğ‘–ğ‘– with adjacent symbol ğ‘ğ‘ï¿½ğ‘–ğ‘– = ğ‘ğ‘ğ‘–ğ‘– + 1

32

Gray Mapping Example
0x 02
0x ğµğµğµ
0x ğ¶ğ¶ğ¶
0x 60
0x A1
0x ğ·ğ·ğ·
ğ‘ğ‘ğ‘–ğ‘– = 0x 62
0x 01
0x 20
0x 28
0x 1C
0x 0ğ¸ğ¸
0x 09

0x ğ¹ğ¹ğ¹
243
0x 21
33
0x 40
64
0x 80
128
0x 23
35
0x ğµğµğµ
177
ğ‘ğ‘ = 0x 93 â‰¡ 147
0x ğ¸ğ¸ğ¸
227
0x 06
6
0x ğ¹ğ¹ğ¹ğ¹
253
0x 18
24
0x ğ·ğ·ğ·ğ·
223
0x ğ¶ğ¶ğ¶ğ¶
207

ai

a
GrayMapping

N
Payload

N
Payload

33

Gray Mapping Matlab Implementation
function g = bin2gray(b)
%BIN2GRAY performs a Gray mapping of the binary vector b
%
The function performs a Gray mapping of the binary vector b according
%
to:
%
g_i = b_i
for i = 0
%
g_i = b_i xor g_i-1 else
len = size(b, 2);
g(len) = b(len);
for idx = 1 : len - 1
x = xor(b(len - idx + 1), b(len - idx));
g(len - idx) = x;
end
end

34

Modulator
preamble

â€¢ After encoding steps, the preamble is added

Encoding
L
p

preamble

a

p

â€¢ The symbols are modulated to the signal

header

s(t)
Modulator

N
payload

payload

frequency (kHz)

62.5

0

time

-62.5

LoRa signal s(t)
35

Modulator Matlab Implementation
function iqdata = LoRa_modulator(symbols, SF, PL, syncword, ovs)
%LORA_MODULATOR creates a LoRa signal
%
This function crates a LoRa signal for the vector symbols with the
%
spreading factor SF, the preamble length PL, the syncword, and the
%
oversampling factor ovs.
iqdata = [];
phaseacc = 0;
%create preamble chirps
for preamble = 1 : PL
[chirp, phaseacc] = lora_chirpsignal(0, SF, 'up', ovs, phaseacc);
iqdata = [iqdata chirp];
end
%create syncword chirps
[chirp, phaseacc] = lora_chirpsignal(floor(syncword/16)*8 , SF, 'up', ovs, phaseacc);
iqdata = [iqdata chirp];
[chirp, phaseacc] = lora_chirpsignal(mod(syncword,16)*8 , SF, 'up', ovs, phaseacc);
iqdata = [iqdata chirp];
%create 2.25 frame delimiter downchirps
[chirp, phaseacc] = lora_chirpsignal(0, SF, 'down', ovs, phaseacc);
iqdata = [iqdata chirp];
[chirp, phaseacc] = lora_chirpsignal(0, SF, 'down', ovs, phaseacc);
iqdata = [iqdata chirp];
[chirp, phaseacc] = lora_chirpsignal(0, SF, 'down_quarter', ovs, phaseacc);
iqdata = [iqdata chirp];
%create chirps for the input symbols
for sym = symbols
[chirp, phaseacc] = lora_chirpsignal(sym, SF, 'up', ovs, phaseacc);
iqdata = [iqdata chirp];
end

36

Chirp-Creation Matlab Implementation
function [chirp, phaseacc] = lora_chirpsignal(symbol, SF,
chirpmode, ovs, phaseacc)
%LORA_CHIRPSIGNAL creates a LoRa chirp
%
The function lora_chirpsignal creates a chirp representing
%
the input symbol with the spreading factor SF, oversampling
%
factor ovs, starting phase paseacc, and the chirpmode:
%
chirpmode = "UP"
upchirp
%
chirpmode = "DOWN"
downchirp
%
chirpmode = "DOWN_QUATER"
downchirp with 1/4 symbol length.
N = 2 ^ SF;
NN = N * ovs;
fMin = -pi / ovs;
fMax = pi / ovs;
fStep = (2 * pi) / (N * ovs * ovs);
f0 = (2 * pi * symbol) / NN;
f = fMin + f0;
%define length for mode "DOWN_QUATER"
if isequal(upper(chirpmode), 'DOWN_QUARTER')
NN = NN / 4;
end
chirp = zeros(1, NN);

%create upchirp
if isequal(upper(chirpmode), 'UP')
for idx = 1 : NN
if f > fMax
f = f - (fMax - fMin);
end
phaseacc = phaseacc + f;
chirp(idx) = exp(1i * phaseacc);
f = f + fStep;
end
end
%create downchirp
if isequal(upper(chirpmode), 'DOWN') || isequal(upper(chirpmode),
'DOWN_QUARTER')
for idx = 1 : NN
if f > fMax
f = f - (fMax - fMin);
end
phaseacc = phaseacc - f;
chirp(idx) = exp(1i * phaseacc);
f = f + fStep;
end
end

37

Example
Same Example with ğ‘†ğ‘†ğ‘†ğ‘† = 11:

payload ğ‘ğ‘ =

â€¢ Whitening:

whitening sequence
whitened payload

ğ‘¤ğ‘¤ =

0x ğ¹ğ¹ğ¹ğ¹
0x ğ¹ğ¹ğ¹ğ¹

ğ‘ğ‘ğ‘¤ğ‘¤ = ğ‘ğ‘ âŠ• ğ‘¤ğ‘¤ =

0x 00
0x 00

0x ğ¹ğ¹ğ¹ğ¹
0x ğ¹ğ¹ğ¹ğ¹

38

Example
Same Example with ğ‘†ğ‘†ğ‘†ğ‘† = 11:
â€¢ Encoding:

payload ğ‘ğ‘ =

ğ¿ğ¿â„ = ğ‘†ğ‘†ğ‘†ğ‘† â€“ 2 = 9

0x 0
0 0 0
0x 2
0 0 1
0x 2
0 0 1
0x 0
0 0 0
â„ = 0x ğ¸ğ¸ = 1 0 1
0x ğ¹ğ¹
1 1 1
0x ğ¹ğ¹
1 1 1
0x ğ¸ğ¸
1 1 1
0x ğ¹ğ¹
1 1 1

0
0
0
0
0
1
1
0
1

ğ‘ğ‘ğ‘¤ğ‘¤

whole payload data fits in remaining space in header
0x ğ¹ğ¹
1
0x ğ¹ğ¹
1
=
ğ‘ğ‘ğ‘¤ğ‘¤ =
0x ğ¸ğ¸
0
0x ğ¹ğ¹
1

1
1
1
1

1
1
1
1

1
1
1
1

ğ‘ğ‘ğ‘¤ğ‘¤ â€² = 0

0x 00
0
0x 27
0
0x 2ğ´ğ´
1
0x 00
0
â„ğ‘’ğ‘’ = 0x ğ´ğ´ğ´ = 0
0x ğ¹ğ¹ğ¹ğ¹
1
0x ğ¹ğ¹ğ¹ğ¹
1
0x ğ¸ğ¸ğ¸
0
0x ğ¹ğ¹ğ¹ğ¹
1

0x 00
0x 00
0
1
0
0
1
1
1
0
1

0
1
1
0
1
1
1
1
1

0
1
0
0
0
1
1
0
1

0
0
0
0
1
1
1
1
1

0
0
0
0
0
1
1
1
1

0
1
1
0
1
1
1
1
1

0
0
0
0
0
1
1
0
1

ğ‘ğ‘ğ‘’ğ‘’ = 0
39

Example
Same Example with ğ‘†ğ‘†ğ‘†ğ‘† = 11:

payload ğ‘ğ‘ =

â€¢ Interleaving:

0x 00
0x 00

8 bit

0
1
1
0
1
1
1
1
1

0
1
0
0
0
1
1
0
1

0
0
0
0
1
1
1
1
1

0
0
0
0
0
1
1
1
1

0
1
1
0
1
1
1
1
1

0
0
0
0
0
1
1
0
1

0x 471
1
0x 3ğ¹ğ¹ğ¹
0
0x ğ¶ğ¶ğ¶ğ¶
0
0x ğ¶ğ¶ğ¶ğ¶
0
â„ğ‘–ğ‘– = ğ‘ğ‘ğ‘–ğ‘– =
=
0x 650
0
0x ğ¹ğ¹ğ¹ğ¹
1
0x 591
1
0x 291
1

0
1
0
0
0
0
1
1

1
1
1
0
1
1
0
0

1
1
1
1
0
1
0
0

1
1
1
1
1
0
1
1

0
0
1
1
0
1
0
0

1
0
1
1
1
1
1
0

0
1
0
0
1
1
0
1

0
1
0
0
0
1
1
0

8 bit

0
1
0
0
1
1
1
0
1

9 bit

0x 00
0
0x 27
0
0x 2ğ´ğ´
1
0x 00
0
â„ğ‘’ğ‘’ = 0x ğ´ğ´ğ´ = 0
0x ğ¹ğ¹ğ¹ğ¹
1
0x ğ¹ğ¹ğ¹ğ¹
1
0x ğ¸ğ¸ğ¸
0
0x ğ¹ğ¹ğ¹ğ¹
1

9 bit

40

Example
Same Example with ğ‘†ğ‘†ğ‘†ğ‘† = 11:
â€¢ Gray Mapping:

0x 471
0x 3ğ¹ğ¹ğ¹
0x ğ¶ğ¶ğ¶ğ¶
0x ğ¶ğ¶ğ¶ğ¶
ğ‘ğ‘ğ‘–ğ‘– =
0x 650
0x ğ¹ğ¹ğ¹ğ¹
0x 591
0x 291

payload ğ‘ğ‘ =

0x 00
0x 00

0x 7ğ´ğ´ğ´
1692
0x 2ğ´ğ´ğ´
648
0x 750
348
0x 820
160
ğ‘ğ‘ğ‘–ğ‘– =
=
0x 460
400
0x 5ğµğµğµ
1748
0x 911
1124
0x ğ¶ğ¶ğ¶ğ¶
1136

41

Example
Same Example with ğ‘†ğ‘†ğ‘†ğ‘† = 11:

payload ğ‘ğ‘ =

â€¢ Resulting signal:

preamble

0x 00
0x 00

header

62.5

time

-62.5

42

Contents
â€¢ Spread Spectrum Basics
â€¢ LoRa Chirped Spread Spectrum
â€¢ LoRa Frame Format
â€¢ LoRa Encoding Scheme
â€¢ Airtime

43

Airtime
â€¢ Payload Length
with:
âˆ’ ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ
âˆ’ ğ‘†ğ‘†ğ‘†ğ‘†
âˆ’ ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶
âˆ’ ğ»ğ»
âˆ’ ğ‘ğ‘
âˆ’ ğ¶ğ¶ğ¶ğ¶

Payload length
Spreading factor
CRC-presence
implicit mode ğ»ğ» = 1, explicit mode ğ»ğ» = 0
Symbol alphabet size
Code rate (ğ¶ğ¶ğ¶ğ¶ = 1 â€¦ 4 representing code rates 4/5, 4/6, 4/7, and 4/8)

â€¢ Airtime of a LoRa signal:

44

Airtime

45

