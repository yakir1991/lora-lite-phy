Practical Solutions for the "Reference Vector Decoding" Issue
Context: You have aligned the LoRa Lite decoder with GNU Radio’s gr-lora_sdr for preamble, sync, and header, but the payload CRC is failing in the reference vector decode test[1]. The header now parses correctly, so the focus is on fixing the payload decoding path (deinterleaving, Hamming decode, dewhitening, CRC) to resolve the CRC mismatch. Below are practical, step-by-step solutions:
1. Verify Bit Ordering and Nibble Packing Consistency
Ensure that bit ordering and nibble ordering are handled exactly as in LoRa spec / GNU Radio for both header and payload:
	Header nibble ordering: In explicit headers, each byte’s high nibble is transmitted first, then the low nibble[2]. Confirm your header bit parser reflects this (it appears you already fixed nibble order during header alignment).
	Payload nibble ordering: For payload bytes, the low nibble is sent first, then high nibble[3]. Make sure your payload bit packing mirrors this scheme. Any discrepancy will scramble the decoded bytes. Align your bit packing so that after deinterleaving you assemble bytes with the correct nibble sequence.
	MSB vs LSB first within each nibble: LoRa uses MSB-first bit packing per symbol in both header and payload. In practice, this means when you form a symbol’s bits into an integer, the most significant bit of that symbol corresponds to the first bit transmitted in that symbol interval[4]. Verify that your Gray demapping and symbol-to-bit logic preserves MSB-first ordering. You might have already tried variant bit-order flips during debugging; now hard-code the correct one (MSB-first) consistently for all decoding.
	Action: Refactor or comment your bit packing code to clearly differentiate header vs payload nibble ordering. For example, implement a helper that assembles 8-bit bytes from two 4-bit nibbles in the required order (one mode for header, one for payload). This removes ambiguity and prevents future mix-ups.
2. Align the Whitening Implementation with LoRa Specification
A misalignment in data whitening can easily cause the CRC to fail. Double-check the following whitening details and implement corrections:
	Do not whiten the header: In explicit mode, the PHY header is not whitened at all[5]. Ensure your decoder does not attempt to dewhiten the 5 header bytes (it sounds like you have this correct already, given header now decodes). The whitening sequence should start fresh after the header.
	Whitening sequence parameters: LoRa uses an 8-bit LFSR to generate a pseudo-random sequence (often called PN9 in Semtech docs, though effectively 8-bit in implementation). The commonly reported feedback polynomial is x^8+x^6+x^5+x^4+1 with an initial seed of 0xFF (all ones)[6][7]. In practice, the SX127x radios XOR each payload byte with one LFSR output byte. Verify that your whitening implementation uses these parameters:
	Initialize the whitening LFSR to 0xFF at the start of payload (after header).
	Use the feedback taps corresponding to the polynomial above. (For example, an 8-bit LFSR with taps at bits 7,5,4,3 will produce the required sequence[6].)
	Generate one output byte per step and XOR with each payload byte (this matches the byte-wise description in literature[8]). If your implementation was bit-wise, it should yield the same result – just ensure the sequence aligns exactly.
	Do not whiten the CRC bytes: This is critical. According to reverse-engineering studies, the two CRC bytes are not whitened in the transmitted LoRa frame[5][9]. In other words, the whitening sequence runs only over the payload data bits and stops before the CRC. In your decoder, you should exclude the CRC field from dewhitening. If you currently dewhiten the entire payload (data+CRC), you are unintentionally altering the CRC bits, leading to a mismatch. Adjust your dewhitening routine to apply XOR only up to payload_length bytes, and leave the last two CRC bytes as-is. This aligns with the finding that when decoding an all-zero payload, the CRC comes out correct only if we do not dewhiten the CRC field[9].
	State continuity: Because the header isn’t whitened, make sure your whitening LFSR is reset and started fresh at the payload start. There should be no carry-over state from any earlier process. After processing all payload data bytes, you can stop generating further whitening bits (since CRC isn’t whitened). This matches the spec behavior where whitening starts after the 5-byte header and covers only the payload data bits[5].
Practical check: After implementing the above, print out a few bytes of the dewhitened payload and compare to GNU Radio’s output or known plaintext if available. The sequences should match bit-for-bit if whitening is correct. Particularly, verify that the last two bytes before CRC calculation remain unchanged by dewhitening (they should match the raw decoded bits from Hamming decode).
3. Correct CRC Computation and Endianness
With proper bits and dewhitened data, focus on the CRC calculation:
	Use the correct CRC-16 algorithm: LoRa uses a 16-bit CRC based on the CRC-CCITT polynomial x^16+x^12+x^5+1 [10]. Ensure your implementation uses this polynomial (often CRC-CCITT with initial value 0xFFFF and no final XOR is the configuration used by Semtech). In your code, verify the CRC generator is set up accordingly. If you were using a different polynomial or initial value, correct it to these standards.
	CRC covers only payload data: The CRC is computed over the payload bytes only, excluding the header and the CRC field itself[11]. It sounds obvious, but double-check that when you validate CRC, you feed the function exactly the first payload_length bytes of the decoded (dewhitened) payload data. Do not include the two CRC bytes in this computation.
	Byte order of transmitted CRC: LoRa transmits the CRC as two bytes. It’s known from LoRaWAN and Semtech’s implementation that the CRC low-order byte is transmitted first, followed by the high-order byte (little-endian on the air). Make sure you interpret the two decoded CRC bytes in the correct order when comparing to your computed CRC. If your CRC checker expects a certain ordering, you may need to swap the bytes. Tip: After dewhitening (with CRC bytes not dewhitened per above), take the last two bytes as crc_lo and crc_hi. Combine them into a 16-bit value as crc_rx = crc_lo | (crc_hi << 8). Compare this to the 16-bit value your CRC routine produced. If it doesn’t match, try the opposite ordering (crc_rx = crc_hi | (crc_lo << 8)) and check again. One of these should match once all other issues are resolved.
	Verify no extra bits/padding: Ensure that the number of bits you fed into the Hamming decoder exactly corresponds to (payload_length + 2) * 8 bits after deinterleaving (for a payload with CRC). No extra pad bits should slip into the CRC calculation. LoRa will pad the payload internally if needed to fill complete codewords, but those pad bits are typically discarded before CRC check. Since your header indicates the exact payload length, trust that and ignore any filler bits beyond the actual data length. If your implementation currently includes pad bits in the data passed to CRC, remove them. (Given your header parse is working, likely you already handle this, but it’s worth confirming.)
Practical check: After making these changes, run a decode on the reference vector and log the computed CRC vs. the received CRC bytes. They should match now. As a sanity test, you can manually compute a CRC-16 on the output payload bytes (using an online tool or a small script with the CCITT polynomial) to confirm it matches the transmitted CRC when interpreted in the correct order.
4. Validate with Debugging and Cross-Testing
Finally, use systematic tests to ensure the above fixes truly resolve the issue:
	Run with known test payload: If possible, generate a simple known payload (e.g., all 0x00 bytes or a pattern, with CRC enabled) using GNU Radio or another reference, and decode it with your implementation. An all-zeros payload is especially useful: after decoding, you expect to see all 0x00 data bytes and a CRC of 0x0000. This case will quickly show if whitening/CRC handling is correct (recall the earlier finding: an all-zero message should yield an all-zero CRC when handled properly[9]). Likewise, a pattern like all 0xFF bytes can test the whitening thoroughly (since whitening 0xFF with 0xFF initial will produce a known sequence).
	Compare with GNU Radio output: Utilize the provided gr_original_rx_only.py (as you mentioned in your log) to get the demodulated bytes from GNU Radio for the same input IQ. Compare, byte by byte, with your decoder’s output before dewhitening, after dewhitening, and final CRC check. This will pinpoint any remaining discrepancy. For example, dump the first few payload bytes after Hamming decode (still whitened) and after dewhitening, and do the same from GNU Radio. They should match when your implementation is correct.
	Additional logging: Temporarily enable detailed logging in your src/rx/frame.cpp (or equivalent) for the payload decoding process:
	Log the raw demodulated symbol values and the bits after Gray demapping for the first several payload symbols.
	Log the deinterleaved bit stream (grouped into nibbles/bytes).
	Log the bytes after Hamming decoding but before dewhitening.
	Log the bytes after dewhitening, and the calculated CRC vs. received CRC.
This granular trace will let you verify each stage. For instance, if the Hamming decoding is wrong, you’d see differences in the pre-dewhiten bytes compared to reference. If only the CRC fails, focus on the dewhitened bytes and CRC logic.
	Iterate on hypotheses if needed: If the CRC still fails after the above changes, revisit the hypotheses[12]:
	Check if the payload bit packing might still be off (e.g. off-by-one symbol alignment or MSB/LSB mix-up).
	Confirm the whitening LFSR implementation exactly matches the expected sequence (any deviation in polynomial or seed will show up as bit errors in patterns).
	Double-check that you are using the header’s indicated coding rate (CR) for the payload. You already fixed using header CR[13], but ensure this flows into how many parity bits you expect per nibble and how your Hamming decoder is configured. An incorrect CR setting in payload decode could scramble bits subtly.
	Verify the Hamming decoder’s correction for CR=4/5,4/6,4/7,4/8. In particular, CR=4/5 uses a single parity bit (no true error correction, just detection), so your decoder should handle that by either checking parity or simply passing data through (since it can’t correct, only flag errors if parity doesn’t match). For CR=4/6,4/7,4/8, ensure the syndrome lookup is correct and that for CR<4/8 you drop the unused parity bits appropriately[14][15]. Any mistakes here could result in flipped bits that the CRC would catch.
	Test with noise (optional): Once the reference vector decodes correctly (CRC passes), test the robustness by adding a known small bit error to the payload and see if CRC fails (it should) and/or if CR=4/8 corrects it. This isn’t strictly necessary for the current issue, but it gives confidence that your Hamming decoding is truly functioning as expected in non-ideal conditions.
By systematically applying the above fixes, your LoRa Lite PHY decoder should correctly decode the reference vector with a passing CRC check. These adjustments align the implementation with LoRa’s specified behavior and GNU Radio’s reference, resolving the mismatch in the “Reference Vector Decoding” scenario. Good luck, and happy testing!
Sources:
	LoRa Lite project notes and logs[1][12] (context of header vs payload decoding issues).
	LoRa PHY design references on whitening and bit ordering[7][2][5].
	Reverse-engineering findings confirming header is unwhitened and CRC bytes are not dewhitened[5][9].
	GNU Radio implementation of LoRa PHY (CRC-16 polynomial and coding rates)[10][14].
________________________________________
[1] [4] [12] [13] PROJECT_NOTES.md
https://github.com/yakir1991/lora-lite-phy/blob/bc4527295b85c48926217451d2df0798d5428f6e/PROJECT_NOTES.md
[2] [3] [7] [8] [10] [11] [14] [15] Design and Implementation of LoRa Physical Layer in GNU Radio
https://pubs.gnuradio.org/index.php/grcon/article/download/145/123/
[5] [9] epfl.ch
https://www.epfl.ch/labs/tcl/wp-content/uploads/2020/02/Reverse_Eng_Report.pdf
[6] Differential and Pulsed Measurements
https://interreg-interop.project.tuwien.ac.at/wp-content/uploads/2024/06/lorawebinar-lora-1.pdf
See [docs/reference_vector_exec_log.md](docs/reference_vector_exec_log.md) for run history.
