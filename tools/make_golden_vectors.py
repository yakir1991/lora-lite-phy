# tools/make_golden_vectors.py
import os, time, inspect, types
from importlib.machinery import SourceFileLoader
from gnuradio import gr
from gnuradio import blocks
import pmt

# Path to the Python script generated by `grcc`
LORA_TX_PY = "/tmp/export_tx_iq/lora_TX.py"

# Map coding-rate (45→4/5 ... 48→4/8) to CR index (1..4)
CR_IDX = {45: 1, 46: 2, 47: 3, 48: 4}

# Base set (~7 files): covers low/high SF, min/max CR, different BWs
CONFIGS = [
    {"sf": 7,  "cr": 45, "bw": 125_000, "fs": 250_000,  "pl": 16, "tag": "base"},
    {"sf": 10, "cr": 45, "bw": 125_000, "fs": 250_000,  "pl": 16, "tag": "base"},
    {"sf": 12, "cr": 45, "bw": 125_000, "fs": 250_000,  "pl": 16, "tag": "ldro"},
    {"sf": 7,  "cr": 48, "bw": 125_000, "fs": 250_000,  "pl": 16, "tag": "crmax"},
    {"sf": 12, "cr": 48, "bw": 125_000, "fs": 250_000,  "pl": 16, "tag": "crmax"},
    {"sf": 9,  "cr": 45, "bw": 250_000, "fs": 500_000,  "pl": 16, "tag": "bw250"},
    {"sf": 7,  "cr": 45, "bw": 500_000, "fs": 1_000_000,"pl": 16, "tag": "bw500"},
]

OUT_DIR = os.path.expanduser("~/projects/lora-lite-phy/vectors")

def try_set(obj, names, value):
    """Try calling set_<name>(value) or assigning attribute <name> directly."""
    for n in names:
        setter = f"set_{n}"
        if hasattr(obj, setter):
            try:
                getattr(obj, setter)(value); return True
            except Exception:
                pass
        if hasattr(obj, n):
            try:
                setattr(obj, n, value); return True
            except Exception:
                pass
    return False

def visit_objects(root):
    """Yield root, then walk shallow attributes to find nested blocks."""
    seen = set()
    stack = [root]
    while stack:
        obj = stack.pop()
        if id(obj) in seen:
            continue
        seen.add(id(obj))
        yield obj
        for name in dir(obj):
            if name.startswith("__"): continue
            try:
                child = getattr(obj, name)
            except Exception:
                continue
            if isinstance(child, (types.FunctionType, types.ModuleType, type)):
                continue
            if hasattr(child, "__dict__") and not isinstance(child, (int, float, str, bytes, bytearray)):
                stack.append(child)

def find_top_block_ctor(mod):
    """Find a class in the module that subclasses gr.top_block and return its ctor."""
    for name in ("top_block_cls", "top_block"):
        ctor = getattr(mod, name, None)
        if callable(ctor): return ctor
    for _, obj in vars(mod).items():
        if inspect.isclass(obj) and issubclass(obj, gr.top_block):
            return obj
    raise AttributeError("Could not find a top block class (subclass of gr.top_block).")

def find_file_sink(tb):
    """Return a File Sink object with an open() method."""
    for obj in visit_objects(tb):
        if hasattr(obj, "open") and obj.__class__.__name__.endswith("file_sink"):
            return obj
    for name in dir(tb):
        if "file_sink" in name:
            obj = getattr(tb, name)
            if hasattr(obj, "open"):
                return obj
    raise RuntimeError("File Sink with an open() method was not found.")

def find_data_source(tb):
    """Heuristically find the LoRa Data source block (expects a 'trigg' msg input)."""
    for obj in visit_objects(tb):
        cls = obj.__class__.__name__.lower()
        if "data_source" in cls or "datasource" in cls:
            return obj
    # Fallback by attribute name
    for name in dir(tb):
        if "data_source" in name:
            return getattr(tb, name)
    return None

def ensure_trigger(tb):
    """
    Ensure there is a message trigger to the Data source. If none,
    create a Message Strobe and msg_connect it to the Data source's 'trigg' port.
    Returns the strobe instance (to keep it alive) or None.
    """
    ds = find_data_source(tb)
    if ds is None:
        print("[WARN] Data source block not found; relying on any internal trigger (if present).")
        return None
    strobe = blocks.message_strobe(pmt.PMT_T, 100)  # 100 ms
    try:
        tb.msg_connect((strobe, "strobe"), (ds, "trigg"))
        print("[INFO] Injected Message Strobe → Data source (trigg)")
        return strobe
    except Exception as e:
        print(f"[WARN] Could not connect strobe to data source: {e}")
        return None

def set_params_everywhere(tb, sf, cr_idx, bw, fs, pl):
    """Try to set parameters on the top block and nested blocks."""
    name_sets = {
        "sf":       ["sf", "SpreadingFactor", "spreading_factor"],
        "cr":       ["cr", "coding_rate", "CR"],
        "bw":       ["bw", "bandwidth", "BW"],
        "fs":       ["samp_rate", "sample_rate", "output_samp_rate", "fs"],
        "pay_len":  ["pay_len", "Pay_len", "payload_len", "payload_length"],
        "n_frames": ["n_frames", "N_frames", "frames"],
    }
    try_set(tb, name_sets["sf"], sf)
    try_set(tb, name_sets["cr"], cr_idx)
    try_set(tb, name_sets["bw"], bw)
    try_set(tb, name_sets["fs"], fs)
    try_set(tb, name_sets["pay_len"], pl)
    try_set(tb, name_sets["n_frames"], 1)
    for obj in visit_objects(tb):
        try_set(obj, name_sets["sf"], sf)
        try_set(obj, name_sets["cr"], cr_idx)
        try_set(obj, name_sets["bw"], bw)
        try_set(obj, name_sets["fs"], fs)
        try_set(obj, name_sets["pay_len"], pl)
        try_set(obj, name_sets["n_frames"], 1)

def run_one(mod, conf):
    sf = conf["sf"]
    cr_idx = CR_IDX[conf["cr"]]
    bw = conf["bw"]
    fs = conf["fs"]
    pl = conf["pl"]

    os.makedirs(OUT_DIR, exist_ok=True)
    fname = f"sf{sf}_cr{conf['cr']}_bw{bw//1000}k_fs{fs}_pl{pl}.bin"
    out_path = os.path.join(OUT_DIR, fname)

    ctor = find_top_block_ctor(mod)
    tb = ctor()

    set_params_everywhere(tb, sf, cr_idx, bw, fs, pl)

    sink = find_file_sink(tb)
    sink.open(out_path)

    strobe = ensure_trigger(tb)  # ← add a trigger if needed

    tb.start()
    time.sleep(1.5)   # 100ms strobe ⇒ 1–2s is plenty for 1 frame
    tb.stop()
    tb.wait()

    size = os.path.getsize(out_path) if os.path.exists(out_path) else 0
    print(f"Wrote {out_path}  ({size} bytes)")
    if size == 0:
        raise RuntimeError(f"Empty file: {out_path} — verify Data source and connections to LoRa Tx exist in the .grc")

def main():
    if not os.path.exists(LORA_TX_PY):
        raise SystemExit(f"Missing {LORA_TX_PY}. Run `grcc` to generate the TX script first.")
    mod = SourceFileLoader("lora_tx_mod", LORA_TX_PY).load_module()
    for conf in CONFIGS:
        run_one(mod, conf)

if __name__ == "__main__":
    main()
